---
title: "Appendix"
output: html_notebook
---


```{r}
knitr::opts_chunk(message=FALSE)
```

```{r}
library(nimble)
library(tidyverse)
```



## Stochastic inflation


```{r}

logistic  <- nimble::nimbleCode({
  
  x[1] <- x0
  for(t in 1:(N-1)){
    mu[t] <- x[t] + x[t] * r * (1 - x[t] / K)
    x[t+1] ~ dnorm(mu[t], sd = sigma)
  }
  
})

p <- list(r = .4, K = 1, sigma = .15, N = 500)

model <- 
nimbleModel(logistic,
            constants = p,
            inits = list(x0 = 1))
cmodel <- compileNimble(model)
set.seed(123)

df <- map_dfr(1:10000, 
              function(rep){
                simulate(cmodel)
                data.frame(t = seq_along(cmodel$x), x = cmodel$x)
              },
              .id = "rep")

df %>% 
  filter(x > 0) %>% 
  group_by(t) %>%
  summarise(ave = mean(x), sd = sd(x)) %>%
  write_csv("inflation.csv")



```

Analytical predicted population size, as a fraction of $K$, is:


```{r}
(1 + sqrt(1 - 8 * p$sigma^2/p$K^2) )/ 2
```
Note this is independent of $r$, and increases with $\sigma/K$, the larger the noise $\sigma_g$ as a fraction of the carrying capacity $K$.  Population sizes can also be inflated relative to their deterministic equilibrium whenever the second derivative is positive (as in the lower equilibrium in the May model of alternative stable states, considered below.)  Stronger nonlinearities (in particular, a larger second derivative at the equilibrium) can drive larger inflationary effects.  



```{r}
df %>% filter(t > 20, x > 0) %>%  summarize(mean(x))
```


```{r}

df %>% 
  filter(x > 0) %>% 
  group_by(t) %>%
  summarise(ave = mean(x), sd = sd(x)) %>%
  gather(moment, value, -t) %>%
  ggplot(aes(t,value, col=moment)) + geom_line()

```





```{r}
p <- list(r = .5, K = 2.1, Q = 5, H = .4, sigma = .04, a = 0.27, N = 1e4)

f <- function(x) x * p$r * (1 - x / p$K)
g <- function(x) p$a * x ^ p$Q / (x^p$Q + p$H^p$Q)

x <- seq(0,2, length.out = 100)
df <- data.frame(x, f = f(x), g = g(x)) 

ggplot(df, aes(x)) + geom_line(aes(y = f)) + geom_line(aes(y = g), col="red") 

ggplot(df, aes(x)) + geom_line(aes(y = f-g)) + 
  geom_hline(aes(yintercept=0), lty=2) +
  coord_cartesian(xlim = c(0,1.5), ylim=c(-.1,.1))  
```


------------



# Quasi-cycles

Understanding the origin of sustained oscillations has long been a central question in ecology [@Hastings1996]


```{r}

quasicycle  <- nimble::nimbleCode({
  
  x[1] <- x0
  y[1] <- y0
  
  for(t in 1:(N-1)){
    mu_x[t] <- x[t] + x[t] * r * (1 - x[t] / K) - b * x[t] * y[t]
    x[t+1] ~ dnorm(mu_x[t], sd = sigma_x)
    mu_y[t] <- y[t] + c * x[t] * y[t] - d * y[t]
    y[t+1] ~ dnorm(mu_y[t], sd = sigma_y)
  }
  
})

p <- 
  data.frame(
  data.frame(r = .1, K = 5,  b = .1, c = .1, d = .1, N = 500),
  data.frame(sigma_x = c(.00001,0.01),  sigma_y = c(.00001,0.01)))




f <- function(constants){
  model <- compileNimble(nimbleModel(quasicycle, constants = constants, inits = list(x0 = 1, y0 = 1)))
  set.seed(123)
  simulate(model)
  tibble(t = seq_along(model$x), x = model$x, y = model$y, sigma = constants$sigma_x)
}

quasicycle_df <- p %>% rowwise() %>% do(f(.))        
write_csv(quasicycle_df, "quasicycles.csv")

quasicycle_df %>%
  gather(species, pop, -t, -sigma) %>%
  ggplot(aes(t, pop, col=species)) + geom_line() + facet_wrap(~sigma)
```


# Stochastic oscillator

May's model


```{r}
p <- list(r = .5, K = 2, Q = 5, H = .38, sigma = .04, a = 0.245, N = 1e4)

f <- function(x) x * p$r * (1 - x / p$K)
g <- function(x) p$a * x ^ p$Q / (x^p$Q + p$H^p$Q)

x <- seq(0,2, length.out = 100)
data.frame(x, f = f(x), g = g(x)) %>%
  ggplot(aes(x)) + geom_line(aes(y = f-g)) + 
  geom_hline(aes(yintercept=0), lty=2) +
  coord_cartesian(xlim = c(0,1.5), ylim=c(-.015,.1))

```

```{r}

may  <- nimble::nimbleCode({
  
  x[1] <- x0
  for(t in 1:(N-1)){
    mu[t] <- x[t] + x[t] * r * (1 - x[t] / K)  - a * x[t] ^ Q / (x[t] ^ Q + H ^ Q)
    y[t+1] ~ dnorm(mu[t], sd = sigma)
    x[t+1] <- max(y[t+1],0)
  }
  
})

model <- nimbleModel(may,constants = p, inits = list(x0 = 1.2))
cmodel <- compileNimble(model)
set.seed(123)
simulate(cmodel)

tibble(t = seq_along(cmodel$x), x = cmodel$x) %>% write_csv("noisy_switch.csv")
read_csv("noisy_switch.csv")  %>% ggplot(aes(t,x)) + geom_line()
```



# Tipping points

Needs a model with non-zero alternate state!

```{r}

tip  <- nimble::nimbleCode({
  
  x[1] <- x0
  for(t in 1:(N-1)){
    mu[t] <- x[t] + x[t] * r * (1 - x[t] / K) * (x[t] - A) / K - h[t]
    y[t+1] ~ dnorm(mu[t], sd = sigma)
    x[t+1] <- max(y[t+1],0)
  }
  
})

p <- list(r = .2, K = 1, A = 0.2, sigma = .01, N = 500, h = seq(0,.03,length=500))

model <- nimbleModel(tip,constants = p, inits = list(x0 = 1))
cmodel <- compileNimble(model)
set.seed(123)
simulate(cmodel)

tibble(t = seq_along(cmodel$x), x = cmodel$x) %>% write_csv("tipping.csv")

read_csv("tipping.csv") %>% ggplot(aes(t,x)) + geom_line()
```


# Turing patterns?





------------


```{r}
data(lynx)
lynx <- tibble(year = 1821:1934, lynx = as.numeric(lynx))

lynx %>%
  ggplot(aes(year,lynx)) + geom_point() + geom_line()
```






